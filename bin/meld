#! /usr/bin/env python

### Copyright (C) 2002-2006 Stephen Kennedy <stevek@gnome.org>

### This program is free software; you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation; either version 2 of the License, or
### (at your option) any later version.

### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.

### You should have received a copy of the GNU General Public License
### along with this program; if not, write to the Free Software
### Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
### USA.

from __future__ import print_function

import locale
import logging
import os
import subprocess
import sys

# On Windows, pythonw.exe (which doesn't display a console window) supplies
# dummy stdout and stderr streams that silently throw away any output. However,
# these streams seem to have issues with flush() so we just redirect stdout and
# stderr to actual dummy files (the equivalent of /dev/null).
# Regarding pythonw.exe stdout, see also http://bugs.python.org/issue706263
if sys.executable.endswith("pythonw.exe"):
    devnull = open(os.devnull, "w")
    sys.stdout = sys.stderr = devnull


def disable_stdout_buffering():

    class Unbuffered(object):

        def __init__(self, file):
            self.file = file

        def write(self, arg):
            self.file.write(arg)
            self.file.flush()

        def __getattr__(self, attr):
            return getattr(self.file, attr)

    sys.stdout = Unbuffered(sys.stdout)


# Support running from an uninstalled version
if os.path.basename(__file__) == "meld":
    self_path = os.path.realpath(__file__)
melddir = os.path.abspath(os.path.join(os.path.dirname(self_path), ".."))

uninstalled = False
if os.path.exists(os.path.join(melddir, "meld.doap")):
    sys.path[0:0] = [melddir]
    uninstalled = True
devel = os.path.exists(os.path.join(melddir, ".git"))

import meld.conf
import meld.settings

if uninstalled:
    meld.conf.uninstalled()
meld.settings.create_settings(uninstalled=uninstalled)

# TODO: Possibly move to elib.intl
import gettext
_ = gettext.gettext
locale_domain = meld.conf.__package__
locale_dir = meld.conf.LOCALEDIR

gettext.bindtextdomain(locale_domain, locale_dir)
locale.setlocale(locale.LC_ALL, '')
gettext.textdomain(locale_domain)
try:
    gettext.install(locale_domain, localedir=locale_dir, unicode=True)
except TypeError:
    # py3k
    gettext.install(locale_domain, localedir=locale_dir)

try:
    if os.name == 'nt':
        from ctypes import cdll
        libintl = cdll.intl
        libintl.bindtextdomain(locale_domain, locale_dir)
        libintl.bind_textdomain_codeset(locale_domain, 'UTF-8')
        del libintl
    else:
        locale.bindtextdomain(locale_domain, locale_dir)
        locale.bind_textdomain_codeset(locale_domain, 'UTF-8')
except AttributeError as e:
    # Python builds linked without libintl (i.e., OSX) don't have
    # bindtextdomain(), which causes Gtk.Builder translations to fail.
    print("Couldn't bind the translation domain. Some translations won't work.")
    print(e)
except locale.Error as e:
    print("Couldn't bind the translation domain. Some translations won't work.")
    print(e)


def check_requirements():

    pyver = (2, 7)
    gtk_requirement = (3, 6)
    glib_requirement = (2, 34, 0)
    gtksourceview_requirement = (3, 6, 0)

    def missing_reqs(mod, ver, exception=None):
        if isinstance(exception, ImportError):
            print(_("Cannot import: ") + mod + "\n" + str(e))
        else:
            modver = mod + " " + ".".join(map(str, ver))
            print(_("Meld requires %s or higher.") % modver)
        sys.exit(1)

    if sys.version_info[:2] < pyver:
        missing_reqs("Python", pyver)

    # gtk+ and related imports
    try:
        # FIXME: Extra clause for gi
        import gi
        from gi.repository import Gtk
        gi.require_version("Gtk", "3.0")
        version = (Gtk.get_major_version(), Gtk.get_minor_version())
        assert version >= gtk_requirement
    except (ImportError, AssertionError) as e:
        missing_reqs("GTK+", gtk_requirement, e)

    try:
        from gi.repository import GObject
        assert GObject.glib_version >= glib_requirement
    except (ImportError, AssertionError) as e:
        missing_reqs("GLib", glib_requirement, e)

    try:
        from gi.repository import GtkSource
        # TODO: There is no way to get at GtkSourceView's actual version
    except (ImportError, AssertionError) as e:
        missing_reqs("GtkSourceView", gtksourceview_requirement, e)


def setup_resources():
    from gi.repository import GObject
    from gi.repository import Gtk
    from gi.repository import Gdk

    GObject.threads_init()
    icon_dir = os.path.join(meld.conf.DATADIR, "icons")
    Gtk.IconTheme.get_default().append_search_path(icon_dir)
    css_file = os.path.join(meld.conf.DATADIR, "meld.css")
    provider = Gtk.CssProvider()
    provider.load_from_path(css_file)
    Gtk.StyleContext.add_provider_for_screen(
        Gdk.Screen.get_default(), provider,
        Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)


def setup_settings():
    if not uninstalled:
        return

    if os.path.exists(os.path.join(meld.conf.DATADIR, "gschemas.compiled")):
        return

    subprocess.call(["glib-compile-schemas", meld.conf.DATADIR], cwd=melddir)


def setup_logging():
    log = logging.getLogger()

    # If we're running uninstalled and from Git, turn up the logging level
    if uninstalled and devel:
        log.setLevel(logging.INFO)
    else:
        log.setLevel(logging.CRITICAL)

    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(asctime)s %(levelname)s "
                                  "%(name)s: %(message)s")
    handler.setFormatter(formatter)
    log.addHandler(handler)


if __name__ == '__main__':
    setup_logging()
    disable_stdout_buffering()
    check_requirements()
    setup_settings()
    setup_resources()

    import meld.meldapp
    status = meld.meldapp.app.run(sys.argv)
    sys.exit(status)
